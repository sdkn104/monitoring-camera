

#include "unistd.h"

//opencv
#include "opencv2/opencv.hpp"
#include "opencv2/video/background_segm.hpp"
// labeling
#include "Labeling.h"

//C
#include <stdio.h>
#include <signal.h>
#include <sys/stat.h>
//C++
#include <iostream>
#include <sstream>
#include <stdexcept>
using namespace cv;
using namespace std;



// My Background Subtractor Class for debug print
struct GMM
{
    float weight;
    float variance;
};

class MyBackgroundSubtractorMOG2 : public BackgroundSubtractorMOG2 {
  public:
   MyBackgroundSubtractorMOG2() {}
   void debug_print(Mat& img, int x, int y) {
        // get pix value of img
        uchar imgval[3];
        if( img.elemSize1() != 1 ) {
          cerr << "ERROR in debug_print()" << endl;
        }
        if( img.channels() == 1 ) {
          imgval[0] = img.at<uchar>(x,y);
        } else if( img.channels() == 3 ) {
          imgval[0] = img.at<Vec3b>(x,y)[0];
          imgval[1] = img.at<Vec3b>(x,y)[1];
          imgval[2] = img.at<Vec3b>(x,y)[2];
        } else {
          cerr << "ERROR in debug_print()" << endl;
        }

        int ncols = frameSize.width;
        int nrows = frameSize.height;
        int nchannels = CV_MAT_CN(frameType);
        if( img.channels() != nchannels ) {
          cerr << "ERROR in debug_print()" << endl;
        }

        uchar* modesUsed0 = bgmodelUsedModes.data;
        uchar* modesUsed = modesUsed0 + ncols*y;
        int nmodes = modesUsed[x];//current number of modes in GMM

        GMM *gmm0 = (GMM*)bgmodel.data;
        GMM* gmm = gmm0 + ncols*nmixtures*y + nmixtures*x;
        float *mean0 = (float*)(bgmodel.data + sizeof(GMM)*nmixtures*nrows*ncols);
        float* mean = mean0 + ncols*nmixtures*nchannels*y + nmixtures*nchannels*x;

        for(int channel=0; channel < nchannels; channel++){
          printf("%3d ",imgval[channel]);
          for(int mode=0; mode < nmodes; mode++) {
            float weight = gmm[mode].weight;
            float var = gmm[mode].variance;
            float* mean_m = mean + mode*nchannels;
            float mean = mean_m[channel];
            printf(" %6g*(%.0f %.1f)", weight, mean, sqrt(var));
          }
          printf("\n");
        }
   }
};


// Global variables
Mat frame; //current frame
Mat fgMask; //fg mask fg mask generated by MOG2 method
Mat bgImg;
Mat fgSumm;
Ptr<BackgroundSubtractor> pBGSub; //MOG2 Background subtractor
Ptr<MyBackgroundSubtractorMOG2> pMyMOG2; //MOG2 Background subtractor

char keyboard; //input from keyboard

int event_gapcnt;
int event_id;
int cnt_outputs;


// parameters
int mthreshold; // in no. of pixes
int event_gap; //
int snapshot_interval;
int output_pictures;
Point debug_point;
double learningRate;
int max_outputs;
int pre_capture;
std::string target_dir;
int limit_frames;


// LABEL
struct LabelData{
  int ind;// インデックス
  cv::Point g;// 重心
  int size; // no. of pixs
};


// UTILs
bool dirExists(const string& dirname) {
  try {
    struct stat st;
    int ret = stat(dirname.c_str(), &st);
    return ret == 0 ? true : false;
  } catch (runtime_error& ex) {
    cerr << "Exception in dirExists(): " << ex.what() << endl;
    return false;
  }
}

bool myImwrite( const string& filename, InputArray img,
              const vector<int>& params=vector<int>())
{
    //cout << "im " << filename << endl;
    if( !dirExists(target_dir) ) {
      cerr << "directory not found: " << target_dir << endl;
      return false;
    }
    try {
        imwrite(filename, img, params);
    }
    catch (runtime_error& ex) {
        cerr << "Exception in myImwrite(): " << ex.what() << endl;
        return false;
    }
    return true;
}


// VIDEO FIFO
class VFifo {
 public:
  
  Mat *fifo;
  unsigned long startIdx;
  unsigned long nextIdx;
  int maxSize;
  int  overflowFlag;

  VFifo() : startIdx(0), nextIdx(0), overflowFlag(0), maxSize(100) {
    fifo = new Mat[maxSize];
  }
  VFifo(int maxSize) : startIdx(0), nextIdx(0), overflowFlag(0), maxSize(maxSize) {
    fifo = new Mat[maxSize];
  }
  ~VFifo() { delete [] fifo; }

  void init()  { /*for(int i=0; i<maxSize; i++)fifo[i] = Mat();*/ }

  int max_size() { return maxSize; }

  int size() {
    return (int)(nextIdx - startIdx);
  }

  void push_back(const Mat& V)  {
    if( size() >= maxSize ) { // overwrite oldest if overflow
      overflowFlag = 1;
      startIdx++;
    }
    V.copyTo(fifo[(nextIdx++)%maxSize]); 
  }

  // idx =  0,1,2,...size()-1 (0 is oldest)
  Mat& get(int idx) { return fifo[(startIdx+idx)%maxSize]; }
  Mat& operator[](int idx) { return get(idx); }

  void clear() { startIdx = nextIdx = 0; }
};

class MyVWriter {
 public:
  MyVWriter() : _filename(""), ovfl(""), VBuf(100) {} 

  // set file name
  void set(const string& filename) {
    if( _filename != "" ) flush();
    _filename = filename;
    ovfl = ""; 
  }

  // write (store to buffer)
  bool write(const Mat& img) {
    VBuf.push_back(img.clone());
    if( VBuf.size() >= VBuf.max_size() ) {
      flush();
    }
  }

  // write out all in buffer
  bool flush() {
      bool rc;
      if( VBuf.size() == 0 ) return true;
      if( !dirExists(target_dir) ) {
        cerr << "directory not found: " << target_dir << endl;
        VBuf.clear();
        return false;
      }
      if( _filename == "" ) return false; // program error
      try {
        string fn = string(_filename);
        fn.insert(fn.rfind("."), ovfl);
        if(vWriter.open(fn, CV_FOURCC('M', 'J', 'P', 'G'), 2, VBuf[0].size(), VBuf[0].channels()==1 ? false : true) ) {
          for(int i=0; i<VBuf.size(); i++) {
            vWriter.write(VBuf[i]);
          }
        }
        rc = true;
      } catch (runtime_error& ex) {
        cerr << "Exception in MyVWriter.flush(): " << ex.what() << endl;
        rc = false;
      }
      vWriter.release();
      VBuf.clear();
      ovfl += "+";
      return rc;
  }

 private:
  VideoWriter vWriter;
  string _filename;
  VFifo VBuf;
  string ovfl;
};
    
MyVWriter myVWriter;
MyVWriter myVWriter2;

// RING BUFFER
#define RingBufferSize 10L
VFifo VRingBuf(RingBufferSize);
VFifo VRingBuf2(RingBufferSize);

#if 0
Mat ringBuffer[RingBufferSize];
long ringBufferIdx = 0;
#define InitRingBuffer()  { /*for(int i=0; i<RingBufferSize; i++)ringBuffer[i] = Mat();*/ }
#define PushRingBuffer(V)  { (V).copyTo(ringBuffer[(ringBufferIdx++)%RingBufferSize]); }
// IDX  0,1,2,...RingBufferSize-1 (0 is oldest)
#define GetRingBuffer(IDX) ringBuffer[(ringBufferIdx+(IDX))%RingBufferSize]
#endif


// FUNCTION DECLARATION
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void processTest(char* flag);
void saveImages();
void handleFrame(int i, const char *rootname);
void Label(const cv::Mat& in_img, cv::Mat& out_img, vector<LabelData>& labels, int min_pix);
char *frameId();


// SIGNAL HANDLER
int intr;
void sigint_handler(int sig) {
  cout << "interrupted" << endl;
  intr = 1;
  //exit(0);
}

void help()
{
    cout
    << "--------------------------------------------------------------------------" << endl
    << "This program shows how to use background subtraction methods provided by "  << endl
    << " OpenCV. You can process both videos (-vid) and images (-img)."             << endl
                                                                                    << endl
    << "Usage:"                                                                     << endl
    << "./bgsub {-vid <video filename>|-img <image filename>}"                     << endl
    << "for example: ./bg_sub -vid video.avi"                                       << endl
    << "or: ./bg_sub -img /data/images/1.png"                                       << endl
    << "--------------------------------------------------------------------------" << endl
    << endl;
}
int main(int argc, char* argv[])
{
//     signal (SIGINT,sigint_handler);


    //print help information
    help();
    //check for the input parameter correctness
    if(argc != 3) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    //create Background Subtractor objects
    //pBGSub = createBackgroundSubtractorMOG2(); //MOG2 approach
    MyBackgroundSubtractorMOG2 mybgsub; //MOG2 approach
    //pBGSub = new BackgroundSubtractorMOG2; //MOG2 approach
    pBGSub = &mybgsub;
    pMyMOG2 = &mybgsub;
    cout << pBGSub->name() << endl;

#if 0
    //pBGSub->set("history",100); // 500 : related to learning rate; see learningRate
    //pBGSub->set("nmixtures",5); // 5 : maximum allowed number of mixture components
    //pBGSub->set("varThreshold",4.0f*4.0f); // 4.0f*4.0f : Tb, related to Cthr ; threshold on the squared Mahalanobis distance to decide if it is well described by the background model or not.
    //pBGSub->set("backgroundRatio",4); //  0.9f : fTB=1-cf : 
    //pBGSub->set("varThresholdGen",4); // 3.0f*3.0f : Tg ; threshold on the squared Mahalan. dist. to decide if a sample is close. 3*3 means 3sigma.
    //pBGSub->set("fVarInit",4); // 15.0f
    //pBGSub->set("fVarMin",4); // 4.0f
    //pBGSub->set("fVarMax",4); // 5*defaultVarInit2
    //pBGSub->set("fCT",0.0f); // 0.05f : CT - complexity reduction prior (minus bias to component weights)
    //pBGSub->set("detectShadows",0); // 1 : 1 -> do shadow detection
    //pBGSub->set("nShadowDetection",4); // 127
    //pBGSub->set("fTau",0.5f); // 0.5f :  shadow threshold
#endif

    // default parameters
    mthreshold = 500; // #of pixes
    event_gap  = 5; // frames
    snapshot_interval = 1; // frames
    output_pictures = 1; // pictures per event. 0:off, 1:all, 2:or
    debug_point = Point(-1, -1);
    learningRate = 0.01; // alpha = learningRate >= 0 && nframes > 1 ? learningRate : 1./min( 2*nframes, history );
    max_outputs = 0;
    pre_capture = 0;
    target_dir = ".";
    limit_frames = 0;

    cout << "writing out.xml..." << endl;
    FileStorage fsw("out.xml", FileStorage::WRITE);
    pMyMOG2->write(fsw);
    fsw << "threshold" << mthreshold;
    fsw << "event_gap" << event_gap;
    fsw << "snapshot_interval" << snapshot_interval;
    fsw << "output_pictures" << output_pictures;
    fsw << "debug_point" << debug_point;
    fsw << "learningRate" << learningRate;
    fsw << "max_outputs" << max_outputs;
    fsw << "pre_capture" << pre_capture;
    fsw << "target_dir" << target_dir;
    fsw << "limit_frames" << limit_frames;
    fsw.release();

    cout << "reading bgsub.xml..." << endl;
    FileStorage fs("bgsub.xml", FileStorage::READ);
    pMyMOG2->read(fs.root());
    fs["threshold"] >> mthreshold;
    fs["event_gap"] >> event_gap;
    fs["snapshot_interval"] >> snapshot_interval;
    fs["output_pictures"] >> output_pictures;
    fs["debug_point"] >> debug_point;
    fs["learningRate"] >> learningRate;
    fs["max_outputs"] >> max_outputs;
    fs["pre_capture"] >> pre_capture;
    fs["target_dir"] >> target_dir;
    fs["limit_frames"] >> limit_frames;
    fs.release();

    event_id = 0; // init
    cnt_outputs = 0; // init
    if(strcmp(argv[1], "-vid") == 0) {
        //input data coming from a video file, or web camera
        processVideo(argv[2]);
    }
    else if(strcmp(argv[1], "-img") == 0) {
        //input data coming from a sequence of images
        processImages(argv[2]);
    }
    else if(strcmp(argv[1], "-save") == 0) {
        saveImages();
    }
    else if(strcmp(argv[1], "-test") == 0) {
        processTest(argv[2]);
    }
    else {
        //error in reading input parameters
        cerr <<"Please, check the input parameters." << endl;
        cerr <<"Exiting..." << endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}


void handleFrame(int fno, const char *rootname) {
        const char *fid = frameId();
        time_t tm = time(NULL);
        char date[50];
        strftime(date, 50, "%Y/%m/%d %H:%M:%S", localtime(&tm));

#if 0
        // convert frame
        Mat cframe;
        cvtColor(frame, cframe, CV_RGB2HLS);
        vector<Mat> hls;
        split(cframe, hls);
        Mat cv(frame.size(), CV_8UC1, Scalar(127));
        vector<Mat> chs;
        chs.push_back(hls[0]);
        chs.push_back(hls[1]);
        chs.push_back(cv);
        merge(chs, cframe);
        cvtColor(cframe, frame, CV_HLS2RGB);
#endif

        //update the background model
        pBGSub->operator()(frame, fgMask, learningRate); // fgMask:8UC1
        pBGSub->getBackgroundImage(bgImg);

        // check move
        Mat bin_img;
        threshold(fgMask, bin_img, 0, 255, THRESH_BINARY); // value=0 or 255
        int mvcnt = countNonZero(bin_img);

        Mat bin_img2;
        erode(bin_img, bin_img2, Mat());
        erode(bin_img2, bin_img, Mat());
        dilate(bin_img, bin_img2, Mat());
        dilate(bin_img2, bin_img, Mat());
        int mvcnt2 = countNonZero(bin_img);
        //cout << mvcnt << " " << mvcnt2 << endl;

        //labeling
        vector<LabelData> labels;
        Mat fgColor(fgMask.size(), CV_8UC3);
        cvtColor(fgMask, fgColor, CV_GRAY2RGB);
        Label(bin_img, fgColor, labels, 100); // min size(#pixs) filter
        int maxsize = labels.size() > 0 ? labels[0].size : 0;
        for(int i=0; i<labels.size(); i++) {
        }

        // event detect
        int status;
        if( fno == 0 ) { // first frame
            event_gapcnt = event_gap+1; // event already end
        }
        if( maxsize > mthreshold ) { // moved
          if( event_gapcnt >= event_gap ) { // beginning of event
            status = 1; // beginning of event (moved)
            event_id++;
          } else {
            status = 5; // middle of event (moved)
          }
          event_gapcnt = 0;
        }else{ // not moved
          ++event_gapcnt;
          if( event_gapcnt == event_gap ) { // end of event
            status = -1; // end of event (not moved)
          } else if( event_gapcnt > event_gap ) {
            status = 0; // out of event
          } else {
            status = -5; // middle of event (not moved)
          }
        }

        // create image
        if( status == 1 ) { //beginning of event (moved)
            // init image
            frame.copyTo(fgSumm); // init
        }
        if( status > 0 ) { // moved
          // create fgColor, update fgSumm
          Mat mask1;
          Mat mask2;
          threshold(fgColor,mask1,254,255,THRESH_BINARY_INV);
          bitwise_and(mask1,fgColor,mask2);
          Mat mask3(fgColor.size(), CV_8UC1);
          cvtColor(mask2, mask3, CV_RGB2GRAY);
          fgColor.copyTo(fgSumm,mask3);
        }

        //put text to frame
        stringstream ss;
        string sfid = string(fid);
        ss << date << "-" << sfid.substr(sfid.size()-1,1) << " " << maxsize;
        rectangle(frame, cv::Point(0, 0), cv::Point(190,13),
                  cv::Scalar(255,255,255), -1);
        string frameNumberString = ss.str();
        putText(frame, frameNumberString.c_str(), cv::Point(1, 10),
                FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(0,0,0));

        //put text to fgColor
        stringstream sss;
        sss << maxsize << "/" << mvcnt;
        rectangle(fgColor, cv::Point(0, 0), cv::Point(90,13),
                  cv::Scalar(255,255,255), -1);
        frameNumberString = sss.str();
        putText(fgColor, frameNumberString.c_str(), cv::Point(1, 10),
                FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(0,0,0));


        if( status == -1 ) { // end of event
            char s[500];
            sprintf(s,"%s/%s_fgsumm_%s_%04d.jpg",target_dir.c_str(), rootname, fid, event_id);
            myImwrite(s, fgSumm);
        }

        //output
        char s[500];
        if( ( max_outputs==0 || cnt_outputs <= max_outputs ) &&
            ( snapshot_interval && fno % snapshot_interval == 0 ) ) {
          cnt_outputs += 1;
          sprintf(s,"%s/%s_frame_%s_%04d.jpg",target_dir.c_str(), rootname, fid, event_id);
          myImwrite(s, frame);
	}
        if( ( max_outputs==0 || cnt_outputs <= max_outputs ) &&
            ( output_pictures == 1 ) ) {
          if( status > 0 ) { // moved
            cnt_outputs += 1;
            sprintf(s,"%s/%s_fgcolor_%s_%04d.jpg",target_dir.c_str(), rootname, fid, event_id);
            myImwrite(s, fgColor);
            //sprintf(s,"%s/%s_fgmask_%s_%04d.jpg",target_dir.c_str(), rootname, fid, event_id);
            //myImwrite(s, fgMask);
            //sprintf(s,"%s/%s_label_%s_%04d.jpg",target_dir.c_str(), rootname, fid, mevent_id);
            //myImwrite(s, label_img);
          }
          if(status==1) { // beginning of event
            cnt_outputs += 1;
            sprintf(s,"%s/%s_bg_%s_%04d.jpg",target_dir.c_str(), rootname, fid, event_id);
            myImwrite(s, bgImg);
            sprintf(s,"%s/%s_video_%s_%04d.avi",target_dir.c_str(), rootname, fid, event_id);
	    myVWriter.set(s);
            sprintf(s,"%s/%s_video2_%s_%04d.avi",target_dir.c_str(), rootname, fid, event_id);
	    myVWriter2.set(s);
            for(int i=RingBufferSize-pre_capture; i<RingBufferSize; i++) {
              if( VRingBuf.size() > 0 ) {
		myVWriter.write(VRingBuf[i]);
              }
              if( VRingBuf2.size() > 0 ) {
                //myVWriter2.write(VRingBuf2[i]);
              }
            }
            myVWriter.write(frame);
            myVWriter2.write(fgMask);
          } else if( status != 0 ) { // in event, not beginning
            cnt_outputs += 1;
            myVWriter.write(frame);
            myVWriter2.write(fgMask);
          }
          if( status == -1 ) { // end of event
            myVWriter.flush();
            myVWriter2.flush();
          }
       }

       //push frame to ring buffer
       VRingBuf.push_back(frame);
       VRingBuf2.push_back(fgMask);

       // debug
       if( debug_point.x >= 0 && debug_point.y >= 0 ) { 
         pMyMOG2->debug_print(frame,debug_point.x,debug_point.y);
       }

       if( limit_frames != 0 && fno >= limit_frames && status == -1 ) {
         cout << "reached frame limit. exit..." << endl;
         exit(0);
       }

}


void processVideo(char* videoFilename) {
    //create the capture object
    VideoCapture capture;
    if( strcmp(videoFilename,"0")==0 ){
      capture.open(0);
    } else {
      capture.open(videoFilename);
    }
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    for(int i=0; keyboard != 'q' && keyboard != 27; i++ ){
        time_t tm = time(NULL);
        char date[50];
        strftime(date, 50, "%Y/%m/%d %H:%M:%S", localtime(&tm));
        cout << "loop " << i << " " << date << endl;

        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        handleFrame(i, "vo");
        //usleep(50*1000);

        if( intr == 1 ) break;
    }

    //delete capture object
    capture.release();
}

void processTest(char *flag) {
    Mat img1(400, 600, CV_8UC3, Scalar(1));
    Mat img2(400, 600, CV_8UC3, Scalar(200));
    for(int i=0; keyboard != 'q' && keyboard != 27; i++ ){
        time_t tm = time(NULL);
        char date[50];
        strftime(date, 50, "%Y/%m/%d %H:%M:%S", localtime(&tm));
        //cout << "loop " << i << " " << date << endl;

        if( i%30 < 10 ) frame = img2;
        else            frame = img1;
        handleFrame(i, "ts");
        //usleep(50*1000);

        if( intr == 1 ) break;
    }
}

void processImages(char* fistFrameFilename) {
    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if(frame.empty()){
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }
    //current image filename
    string fn(fistFrameFilename);
    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    for(int i=0;  keyboard != 'q' && keyboard != 27; i++ ){
        cout << i << " " << fn << endl;
        handleFrame(i, "ir");

        //get the input from the keyboard
        keyboard = (char)waitKey( 30 );

        //search for the next image in the sequence
        size_t index = fn.find_last_of("_");
        size_t index2 = fn.find_last_of(".");
        string prefix = fn.substr(0,index+1);
        string suffix = fn.substr(index2);
        string frameNumberString = fn.substr(index+1, index2-index-1);
        int no = atoi(frameNumberString.c_str());
        char s[100];
        sprintf(s,"%06d",no+1);
        string nextFrameFilename = prefix + string(s) + suffix;
        //read the next frame
        frame = imread(nextFrameFilename);
        if(frame.empty()){
            //error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //update the path of the current frame
        fn.assign(nextFrameFilename);

        if( intr == 1 ) break;
    }
}


void saveImages() {
    //create the capture object
    VideoCapture capture(0);
    if(!capture.isOpened()){
        cerr << "Unable to capture" << endl;
        exit(EXIT_FAILURE);
    }
    // loop
    for(int i=0; 1 ; i++ ){
if( i > 3600*2 ) return;
        time_t tm = time(NULL);
        char *date = asctime(localtime(&tm));
        char dt[18];
        strftime(dt, 18, "%Y%m%d%H%M%S", localtime(&tm));
        cout << "loop " << i << " " << date;

        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        //put text on the current frame
        //stringstream ss;
        //ss << date;
        //rectangle(frame, cv::Point(10, 2), cv::Point(200,20),
        //          cv::Scalar(255,255,255), -1);
        //string frameNumberString = ss.str();
        //putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
        //        FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));

        char s[100];
        sprintf(s,"%s/frame_%06d.jpg",target_dir.c_str(), i);
        myImwrite(s, frame);
        
        usleep(400*1000);
    }

    //delete capture object
    capture.release();
}



// 適当な色を出す用
cv::RNG rnd(1192);
cv::Scalar randomColor()
{
	return cv::Scalar((rnd(215)+20) & 0xFF, (rnd(215)+20) & 0xFF, (rnd(215)+20) & 0xFF);
}
/*
 * 2値画像をラベリングする関数
 */
void Label(const cv::Mat& in_img, // 8UC1
	   cv::Mat& out_img,  // CV_8UC3
	   vector<LabelData>& labels,
	   int min_pix){
  
  // ラベリングの結果を受け取る行列
  cv::Mat label(in_img.size(), CV_16SC1);
  cv::Mat label8(in_img.size(), CV_8UC1);
    
  // ラベリングを実施 ２値化した画像に対して実行する
  LabelingBS labeling;
  labeling.Exec( in_img.data,	      // 二値化画像 8UC1
		 (short *)label.data, // ラベリング結果 16SC1
		 in_img.cols, 
		 in_img.rows, 
		 true,		// sortするかどうか
		 min_pix);	// TODO: sort == falseにするとmin_pixが有効にならない？
  label.convertTo(label8,CV_8UC1);

  // ラベルされた領域をひとつずつ描画
  cout << " label:";
  int num_label = labeling.GetNumOfRegions();
  for( int i=0; i<num_label; i++){
    RegionInfoBS *ri = labeling.GetResultRegionInfo(i);

    int size = ri->GetNumOfPixels();
    cout << " " << size;

    // ラベリング結果の領域を抽出する
    cv::Mat labelarea;
    cv::compare(label8, i+1, labelarea, CV_CMP_EQ); // labelarea:same type as label

    // 重心座標の取得/
    float x,y;
    ri->GetCenter(x, y);
    
    // ラベル構造体のvectorへ格納
    LabelData l;
    l.g.x = x;
    l.g.y = y;
    l.ind = i;
    l.size = size;
    labels.push_back(l);

    if( ri->GetNumOfPixels() < min_pix ) continue;

    // 抽出した領域にランダムな色を設定して出力画像に追加
    cv::Mat color(in_img.size(), CV_8UC3, randomColor());
    color.copyTo(out_img, labelarea); // 
  }
  cout << endl;
}


char* frameId() {
  static time_t prev = 0;
  static int cnt = 0;
  static char id[20];

  time_t now = time(NULL);
  if( now == prev ) 
    cnt++;
  else
    cnt = 0;

  strftime(id, 15, "%Y%m%d%H%M%S", localtime(&now));
  sprintf(id+14, "%d", cnt);

  prev = now;
  return id;
}

